// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thread>
#include <mutex>
#include <queue>
#include <vector>
#include <condition_variable>
#include <unistd.h>
#include <iostream>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::match_service;
using namespace ::save_service;
using namespace std;
struct Task
{
    User user;
    string type;
};
struct MessageQueue
{
    queue<Task>q;
    mutex m;
    condition_variable cv;
}messagequeue;
class Pool
{
    public:
        void add(User user)
        {
            users.push_back(user);
            cnt.push_back(0);
        }
        void remove(User user)
        {
            for(uint32_t i=0;i<users.size();i++)
            {
                if(users[i].id==user.id)
                {
                    users.erase(users.begin()+i);
                    cnt.erase(cnt.begin()+i);
                    break;
                }
            }
        }
        bool check(int i,int j)
        {
            auto a=users[i],b=users[j];
            int df=abs(a.score-b.score);
            int maxa=50*cnt[i];
            int maxb=50*cnt[j];
            return df<=maxa&&df<=maxb;
        }
        void save(int a,int b)
        {
            printf("match %d %d\n",a,b);
            std::shared_ptr<TTransport> socket(new TSocket("123.57.47.211", 9090));
            std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            SaveClient client(protocol);

            try {
                transport->open();
                client.save_data("acs_2237","e3431091",a,b);
                transport->close();
            } catch (TException& tx) {
                cout << "ERROR: " << tx.what() << endl;
            }
        }
        void match()
        {
            for(uint32_t i=0;i<cnt.size();i++)
            {
                cnt[i]++;
            }
            while(users.size()>1)
            {
                int flag=0;
                for(uint32_t i=0;i<users.size();i++)
                {
                    for(uint32_t j=i+1;j<users.size();j++)
                    {
                        if(check(i,j))
                        {
                            save(users[i].id,users[j].id);
                            flag=1;
                            users.erase(users.begin()+j);
                            cnt.erase(cnt.begin()+j);
                            users.erase(users.begin()+i);
                            cnt.erase(cnt.begin()+i);
                            break;
                        }
                    }
                    if(flag)break;
                }
                if(!flag)break;
            }
        }
    private:
        vector<int>cnt;
        vector<User>users;
}pool;
class MatchHandler : virtual public MatchIf {
    public:
        MatchHandler() {
            // Your initialization goes here
        }

        /**
         * user: 添加的用户信息
         * info: 附加信息
         * 在匹配池中添加一个名用户
         * 
         * @param user
         * @param info
         */
        int32_t add_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("add_user\n");
            unique_lock<mutex>lck(messagequeue.m);
            messagequeue.q.push({user,"add"});
            return 0;
        }

        /**
         * user: 删除的用户信息
         * info: 附加信息
         * 从匹配池中删除一名用户
         * 
         * @param user
         * @param info
         */
        int32_t remove_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("remove_user\n");
            unique_lock<mutex>lck(messagequeue.m);
            messagequeue.q.push({user,"remove"});
            return 0;
        }

};
void consume()
{
    while(true)
    {
        unique_lock<mutex>lck(messagequeue.m);
        if(messagequeue.q.empty())
        {
            lck.unlock();
            pool.match();
            sleep(1);
        }
        else
        {
            auto task=messagequeue.q.front();
            messagequeue.q.pop();
            lck.unlock();
            if(task.type=="add")pool.add(task.user);
            else if(task.type=="remove")pool.remove(task.user);

        }
    }
}
int main(int argc, char **argv) {
    int port = 9090;
    ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
    ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
    ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    cout<<"match_server start!!"<<endl;
    thread match_thread(consume);
    server.serve();
    return 0;
}

